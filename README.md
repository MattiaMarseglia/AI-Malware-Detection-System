# Malware Detection System

<div align="center">
  <img src="malware-detection.png" alt="CARLA Simulator">
</div>

## Overview

Malwares are malicious software that infect digital systems, posing a major threat to digital security. They exploit system vulnerabilities, such as programming errors, to execute attacks that can cause extensive damage, including extortion through ransomware, Denial of Service (DoS) attacks using worms, and data theft via spyware.

In 2022, cyber-attacks increased significantly in both quantity and severity. The Clusit report highlighted that 32% of attacks were "critical" and 47% were "high" in severity, affecting credibility, finances, society, and geopolitics.

Malware detection is crucial in defending against these threats. Traditional techniques include Signature-Based detection and Checksumming, which compare software signatures against a database. However, these methods struggle with real-time detection of unknown malware.

Dynamic techniques, such as Behavioral detection, analyze software in a sandbox to identify malicious behavior. These methods are complex and resource-intensive.

The new frontier in malware detection leverages Artificial Intelligence (AI). Machine Learning Algorithms (MLAs) are essential for effective analysis, as modern malware employs techniques like polymorphism and metamorphism to evade detection. These AI-based approaches, though time-consuming, offer enhanced detection capabilities.

This project explores Machine Learning, Deep Learning, and Natural Language Processing (NLP) methodologies to classify binary files as malware or benign.

## Technologies Used

### Project Constraints and Model Selection
The project required selecting three models for malware detection, with at least one model based on machine learning. Various models were tested, ranging from deep learning image-based CNNs to natural language processing techniques. Models were evaluated based on their performance on a validation set derived from Dataset 1 using an 80-20 split. The models were selected based on accuracy, and only the top-performing models were chosen for further investigation.

### Natural Language Processing (NLP)
NLP involves processing text to analyze, interpret, and represent it. For malware detection, this requires extracting a corpus from binary files to analyze using NLP techniques. Specifically, API call sequences were extracted from the assembly source files using the Lief library, due to resource constraints preventing opcode extraction. These sequences were then vectorized using the Doc2Vec model, which generates word embeddings by leveraging semantic and syntactic information from the text.

### Feature Extraction: API Calls
API calls allow programs to interact with other programs through defined interfaces. In PE files, API calls interact with Dynamic-Link Libraries (DLLs). Analyzing these calls helps determine a file's behavior by examining its interactions with the operating system or common libraries. For this project, API calls were extracted from the assembly source files using the Lief library.

### Analyzed Approaches
The extracted feature vectors were initially evaluated using KNeighborsClassifier and LogisticRegression models, chosen for their ease of use and low computational complexity. The top 5 Doc2Vec models were further analyzed using a Random Forest and a 1D Convolutional Neural Network (CNN).

#### Random Forest
Random Forest training involved a Random Search over parameters such as Criterion (gini, entropy), Number of estimators (10, 1000), and Maximum Depth (2, 32). The best parameters were selected based on accuracy.

#### CNN 1D
The 1D CNN model applied monodimensional convolutional layers to the vectorized output, scanning the sequence for features.

### Ensemble Classifiers
Ensemble classifiers were used to create a robust system against obfuscation, combining weak learners into a strong predictor. Approaches included Random Forests, Gradient Boosting architectures, and custom ensembles, leveraging features extracted through the EMBER framework.

### Feature Extraction: Ember Features
Given the binary nature of the datasets, pre-processing was necessary. The EMBER framework was used to convert raw data into a clean dataset for algorithm training.

### Image-Based Approaches
This technique utilized CNNs, leveraging their generalization power for tasks beyond computer vision. Binary files were converted to grayscale images by segmenting 8-bit vectors into pixels, following the methodology outlined in the literature. Different models, such as ResNet50, Inception V3, and EfficientNetV2, were tested with the generated images.

### MalConv-Based Networks
Classical machine learning approaches rely on extensive feature engineering, making them susceptible to evasion once attackers identify the features used. Treating raw binaries as images can be problematic due to loss of code structure and conflation of vertical and horizontal proximities. Instead, using an embedding space concept from NLP, MalConv was used to classify malware from raw bytes, reducing the need for constant feature engineering. This approach uses an embedding layer over an alphabet of 257 tokens, with the network analyzing files through convolutional blocks with a gating mechanism.

### Robustness of Chosen Approaches
We conducted an experimentation in which we tested the robustness of the chosen models. Obviously, the different malware families are already very diverse, and the number and possible obfuscations that could be applied are very high, so a Malware Detection system should take many different aspects into consideration. Because of this reason, it is not possible to have a “brute force” approach regarding this problem. So, it is necessary to insert a general approach with good performance in all situations. But at this point, a question arises: “How can computers learn to solve problems without being explicitly programmed?”.

To tackle that central question, different approaches were proposed, among them the use of the biological theory of evolution arose. Hence, Holland demonstrated how evolution in nature can be applied to solve problems using a technique called Genetic Algorithms (GA). GA converts a population of individuals with its respective fitness through operations including crossover and mutation following the Darwinian principle. Combining that approach with computer programs brings us to Genetic Programs, which is an approach to automated machine learning that attempts to evolve programs to solve a variety of problems that have been extensively studied for decades.

Among these genetic algorithms, GAMMA was chosen in order to generate the obfuscated samples. The parameters required for the attack were:
- x the malware that must be obfuscated.
- s a manipulation to be applied on it.
- f(x) the output of the classification.

The aim of the algorithm is to minimize a function F(s) that consists of the sum of two conflicting terms:
- f (x ⊕ s): the classification output on the manipulated program (where x ⊕ s is a new malware where the s manipulation is applied),
- λ * C(s): a weighted penalty function that evaluates the number of injected bytes into the input malware.

λ is > 0 and tunes the trade-off between these two terms, in fact it promotes solutions with a smaller number of injected bytes C(s) at the expense of reducing the probability that the sample is misclassified as benign. This was the main parameter used to generate the Security Evaluation Curves shown below.

### Dataset Details

#### PE File
PE (Portable Executable) files are the standard executable file format in Windows. Understanding the structure and features of PE files is critical for effective malware analysis.

#### Dataset 1: Training Dataset
The training dataset comprises labeled samples used to train the machine learning models. It includes a balanced mix of benign and malicious files.

#### Dataset 2: Generalization
The generalization dataset is used to evaluate the models' performance on unseen data, ensuring that the models generalize well beyond the training data.

## Repository Structure

- `CNN/`:
  - Contains the implementation and related files for the Convolutional Neural Network (CNN) based malware detection method.
- `Doc2Vec/`:
  - Contains the implementation and related files for the Doc2Vec based malware detection method.
- `EnsembleClassifiers/`:
  - Contains the implementation and related files for the ensemble classifiers used in malware detection.
- `MalConvBased/`:
  - Contains the implementation and related files for the MalConv based malware detection method.
- `checkpoints/`:
  - Stores model checkpoints from the training process.
- `features/`:
  - Contains scripts and files for feature extraction from malware samples.
- `MalwareDetectionandRobustnessEvaluation.pdf`:
  - Comprehensive documentation on feature extraction, training, validation procedures, and experimental results analysis.

## Feedback

For any feedback, questions, or inquiries, please contact the project maintainers listed in the Contributors section.

**Note:** This project is for educational purposes only, and the use of malware-related datasets and tools should adhere to ethical guidelines and legal standards.
